import type { Test, UIStep } from '@/types/test';

export interface ExportOptions {
  language: 'playwright' | 'cypress' | 'selenium';
  typescript: boolean;
  includeComments: boolean;
}

export class CodeExportService {
  /**
   * Generate Playwright test code
   */
  static generatePlaywright(
    test: Test,
    dataSets: Record<string, string>[],
    options: { typescript?: boolean; includeComments?: boolean } = {}
  ): string {
    const { includeComments = true } = options;
    const steps = test.steps.filter((s): s is UIStep => s.type === 'ui');

    let code = '';

    // Imports
    code += `import { test, expect } from '@playwright/test';\n\n`;

    // Comments
    if (includeComments) {
      code += `/**\n`;
      code += ` * Test: ${test.name}\n`;
      code += ` * Generated by QAerx\n`;
      code += ` * URL: ${test.url}\n`;
      code += ` */\n\n`;
    }

    // Test data
    if (dataSets.length > 0 && Object.keys(dataSets[0]).length > 0) {
      code += `const testData = ${JSON.stringify(dataSets, null, 2)};\n\n`;

      // Data-driven test
      code += `for (const data of testData) {\n`;
      code += `  test(\`${test.name} - \${JSON.stringify(data)}\`, async ({ page }) => {\n`;
    } else {
      code += `test('${test.name}', async ({ page }) => {\n`;
    }

    // Navigation
    if (test.url && test.url !== 'https://') {
      const indent = dataSets.length > 0 ? '    ' : '  ';
      code += `${indent}// Navigate to test URL\n`;
      code += `${indent}await page.goto('${this.escapeString(test.url)}');\n\n`;
    }

    // Steps
    const indent = dataSets.length > 0 ? '    ' : '  ';
    steps.forEach((step, index) => {
      if (includeComments) {
        code += `${indent}// Step ${index + 1}: ${step.name}\n`;
      }
      code += this.generatePlaywrightStep(step, indent, dataSets.length > 0);
      code += '\n';
    });

    // Close test
    if (dataSets.length > 0 && Object.keys(dataSets[0]).length > 0) {
      code += `  });\n`;
      code += `}\n`;
    } else {
      code += `});\n`;
    }

    return code;
  }

  /**
   * Generate Cypress test code
   */
  static generateCypress(
    test: Test,
    dataSets: Record<string, string>[],
    options: { typescript?: boolean; includeComments?: boolean } = {}
  ): string {
    const { includeComments = true } = options;
    const steps = test.steps.filter((s): s is UIStep => s.type === 'ui');

    let code = '';

    // Comments
    if (includeComments) {
      code += `/**\n`;
      code += ` * Test: ${test.name}\n`;
      code += ` * Generated by QAerx\n`;
      code += ` * URL: ${test.url}\n`;
      code += ` */\n\n`;
    }

    // Test data
    if (dataSets.length > 0 && Object.keys(dataSets[0]).length > 0) {
      code += `const testData = ${JSON.stringify(dataSets, null, 2)};\n\n`;
    }

    // Describe block
    code += `describe('${test.name}', () => {\n`;

    // Before each - navigation
    if (test.url && test.url !== 'https://') {
      code += `  beforeEach(() => {\n`;
      code += `    cy.visit('${this.escapeString(test.url)}');\n`;
      code += `  });\n\n`;
    }

    // Data-driven tests
    if (dataSets.length > 0 && Object.keys(dataSets[0]).length > 0) {
      code += `  testData.forEach((data, index) => {\n`;
      code += `    it(\`should complete test with data set \${index + 1}\`, () => {\n`;
      const indent = '      ';
      steps.forEach((step, stepIndex) => {
        if (includeComments) {
          code += `${indent}// Step ${stepIndex + 1}: ${step.name}\n`;
        }
        code += this.generateCypressStep(step, indent, true);
        code += '\n';
      });
      code += `    });\n`;
      code += `  });\n`;
    } else {
      code += `  it('should complete successfully', () => {\n`;
      const indent = '    ';
      steps.forEach((step, index) => {
        if (includeComments) {
          code += `${indent}// Step ${index + 1}: ${step.name}\n`;
        }
        code += this.generateCypressStep(step, indent, false);
        code += '\n';
      });
      code += `  });\n`;
    }

    code += `});\n`;

    return code;
  }

  /**
   * Generate Selenium test code (Python)
   */
  static generateSelenium(
    test: Test,
    dataSets: Record<string, string>[],
    options: { includeComments?: boolean } = {}
  ): string {
    const { includeComments = true } = options;
    const steps = test.steps.filter((s): s is UIStep => s.type === 'ui');

    let code = '';

    // Imports
    code += `from selenium import webdriver\n`;
    code += `from selenium.webdriver.common.by import By\n`;
    code += `from selenium.webdriver.support.ui import WebDriverWait\n`;
    code += `from selenium.webdriver.support import expected_conditions as EC\n`;
    code += `from selenium.webdriver.support.select import Select\n`;
    code += `import unittest\n`;
    code += `import time\n\n`;

    // Comments
    if (includeComments) {
      code += `"""\n`;
      code += `Test: ${test.name}\n`;
      code += `Generated by QAerx\n`;
      code += `URL: ${test.url}\n`;
      code += `"""\n\n`;
    }

    // Test data
    if (dataSets.length > 0 && Object.keys(dataSets[0]).length > 0) {
      code += `test_data = ${JSON.stringify(dataSets, null, 4).replace(/"/g, "'").replace(/null/g, 'None')}\n\n`;
    }

    // Test class
    code += `class Test${this.toPascalCase(test.name)}(unittest.TestCase):\n`;
    code += `    def setUp(self):\n`;
    code += `        self.driver = webdriver.Chrome()\n`;
    code += `        self.driver.implicitly_wait(10)\n`;

    if (test.url && test.url !== 'https://') {
      code += `        self.driver.get("${test.url}")\n`;
    }
    code += `\n`;

    code += `    def tearDown(self):\n`;
    code += `        self.driver.quit()\n\n`;

    // Test method
    if (dataSets.length > 0 && Object.keys(dataSets[0]).length > 0) {
      code += `    def test_with_data(self):\n`;
      code += `        for data in test_data:\n`;
      const indent = '            ';
      steps.forEach((step, index) => {
        if (includeComments) {
          code += `${indent}# Step ${index + 1}: ${step.name}\n`;
        }
        code += this.generateSeleniumStep(step, indent, true);
        code += '\n';
      });
    } else {
      code += `    def test_main(self):\n`;
      const indent = '        ';
      steps.forEach((step, index) => {
        if (includeComments) {
          code += `${indent}# Step ${index + 1}: ${step.name}\n`;
        }
        code += this.generateSeleniumStep(step, indent, false);
        code += '\n';
      });
    }

    code += `\nif __name__ == "__main__":\n`;
    code += `    unittest.main()\n`;

    return code;
  }

  // ==================== HELPER METHODS ====================

  private static generatePlaywrightStep(step: UIStep, indent: string, hasData: boolean): string {
    const action = step.action as any;
    const selector = step.selectors[0]?.value || '';

    const substituteVars = (text: string) => {
      if (hasData) {
        return text.replace(/\{\{(\w+)\}\}/g, '${data.$1}');
      }
      return text;
    };

    switch (action.type) {
      case 'navigate':
        const url = substituteVars(action.url || '');
        return `${indent}await page.goto(\`${url}\`);`;

      case 'click':
        return `${indent}await page.locator('${this.escapeString(selector)}').click();`;

      case 'dblclick':
        return `${indent}await page.locator('${this.escapeString(selector)}').dblclick();`;

      case 'type':
        const text = substituteVars(action.text || '');
        return `${indent}await page.locator('${this.escapeString(selector)}').fill(\`${text}\`);`;

      case 'select':
        const value = substituteVars(action.value || '');
        return `${indent}await page.locator('${this.escapeString(selector)}').selectOption(\`${value}\`);`;

      case 'check':
        return `${indent}await page.locator('${this.escapeString(selector)}').check();`;

      case 'uncheck':
        return `${indent}await page.locator('${this.escapeString(selector)}').uncheck();`;

      case 'waitTime':
        return `${indent}await page.waitForTimeout(${action.duration || 2000});`;

      case 'waitForElement':
        return `${indent}await page.locator('${this.escapeString(selector)}').waitFor();`;

      case 'scroll':
        return `${indent}await page.evaluate(() => window.scrollTo(${action.x || 0}, ${action.y || 0}));`;

      default:
        return `${indent}// Unknown action: ${action.type}`;
    }
  }

  private static generateCypressStep(step: UIStep, indent: string, hasData: boolean): string {
    const action = step.action as any;
    const selector = step.selectors[0]?.value || '';

    const substituteVars = (text: string) => {
      if (hasData) {
        return text.replace(/\{\{(\w+)\}\}/g, '${data.$1}');
      }
      return text;
    };

    switch (action.type) {
      case 'navigate':
        const url = substituteVars(action.url || '');
        return `${indent}cy.visit(\`${url}\`);`;

      case 'click':
        return `${indent}cy.get('${this.escapeString(selector)}').click();`;

      case 'dblclick':
        return `${indent}cy.get('${this.escapeString(selector)}').dblclick();`;

      case 'type':
        const text = substituteVars(action.text || '');
        return `${indent}cy.get('${this.escapeString(selector)}').clear().type(\`${text}\`);`;

      case 'select':
        const value = substituteVars(action.value || '');
        return `${indent}cy.get('${this.escapeString(selector)}').select(\`${value}\`);`;

      case 'check':
        return `${indent}cy.get('${this.escapeString(selector)}').check();`;

      case 'uncheck':
        return `${indent}cy.get('${this.escapeString(selector)}').uncheck();`;

      case 'waitTime':
        return `${indent}cy.wait(${action.duration || 2000});`;

      case 'waitForElement':
        return `${indent}cy.get('${this.escapeString(selector)}').should('be.visible');`;

      case 'scroll':
        return `${indent}cy.scrollTo(${action.x || 0}, ${action.y || 0});`;

      default:
        return `${indent}// Unknown action: ${action.type}`;
    }
  }

  private static generateSeleniumStep(step: UIStep, indent: string, hasData: boolean): string {
    const action = step.action as any;
    const selector = step.selectors[0]?.value || '';

    const substituteVars = (text: string) => {
      if (hasData) {
        return text.replace(/\{\{(\w+)\}\}/g, "' + data['$1'] + '");
      }
      return text;
    };

    // Determine selector strategy
    const getByStrategy = (sel: string) => {
      if (sel.startsWith('#')) return `By.ID, "${sel.slice(1)}"`;
      if (sel.startsWith('.') && !sel.includes(' ')) return `By.CLASS_NAME, "${sel.slice(1)}"`;
      if (sel.startsWith('//')) return `By.XPATH, "${sel}"`;
      return `By.CSS_SELECTOR, "${sel}"`;
    };

    const by = getByStrategy(selector);

    switch (action.type) {
      case 'navigate':
        const url = substituteVars(action.url || '');
        return `${indent}self.driver.get('${url}')`;

      case 'click':
        return `${indent}self.driver.find_element(${by}).click()`;

      case 'dblclick':
        return `${indent}from selenium.webdriver.common.action_chains import ActionChains\n${indent}ActionChains(self.driver).double_click(self.driver.find_element(${by})).perform()`;

      case 'type':
        const text = substituteVars(action.text || '');
        return `${indent}element = self.driver.find_element(${by})\n${indent}element.clear()\n${indent}element.send_keys('${text}')`;

      case 'select':
        const value = substituteVars(action.value || '');
        return `${indent}Select(self.driver.find_element(${by})).select_by_value('${value}')`;

      case 'check':
        return `${indent}checkbox = self.driver.find_element(${by})\n${indent}if not checkbox.is_selected():\n${indent}    checkbox.click()`;

      case 'uncheck':
        return `${indent}checkbox = self.driver.find_element(${by})\n${indent}if checkbox.is_selected():\n${indent}    checkbox.click()`;

      case 'waitTime':
        return `${indent}time.sleep(${(action.duration || 2000) / 1000})`;

      case 'waitForElement':
        return `${indent}WebDriverWait(self.driver, 30).until(EC.presence_of_element_located((${by})))`;

      case 'scroll':
        return `${indent}self.driver.execute_script("window.scrollTo(${action.x || 0}, ${action.y || 0})")`;

      default:
        return `${indent}# Unknown action: ${action.type}`;
    }
  }

  private static escapeString(str: string): string {
    return str.replace(/'/g, "\\'").replace(/"/g, '\\"');
  }

  private static toPascalCase(str: string): string {
    return str
      .replace(/[^a-zA-Z0-9]/g, ' ')
      .split(' ')
      .filter(Boolean)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }
}
